---
id: P7.M3.E5.T001
title: Add authorization checks to tool registration
status: done
estimate_hours: 2.0
complexity: medium
priority: medium
depends_on: []
tags:
- security
- registry
- authorization
- audit
claimed_by: cli-user
claimed_at: '2026-02-07T01:54:55.356958+00:00'
started_at: '2026-02-07T01:54:55.356958+00:00'
completed_at: '2026-02-07T02:49:24.255845+00:00'
duration_minutes: 54.481647566666666
---

# Add authorization checks to tool registration

Currently `Registry.register/1` and `Registry.register_with_schema/2` accept any module without
authorization context. Any code path can register arbitrary tools into the global registry, and
there is no audit trail for when tools are registered or unregistered. This creates a risk where
malicious or buggy code could inject tools that override or shadow existing ones.

This task adds optional authorization context to tool registration and comprehensive audit logging
via telemetry events.

## Requirements

- [ ] Extend `Registry.register/1` to accept an optional authorization context:
  - Add `register/2` overload: `register(module, opts \\ [])`
  - `opts` can include `[authorized_by: "system" | "mcp:server_name" | "admin:user_id"]`
  - When `authorized_by` is not provided, default to `"system"` for backward compatibility
- [ ] Extend `Registry.register_with_schema/2` similarly:
  - Add `register_with_schema/3`: `register_with_schema(module, schema, opts \\ [])`
- [ ] Add telemetry events for registration lifecycle:
  - `[:pag_server, :tools, :registry, :register]` - emitted on successful registration
    - Metadata: `%{tool_name: name, module: module, authorized_by: source}`
  - `[:pag_server, :tools, :registry, :register_failed]` - emitted on failed registration
    - Metadata: `%{module: module, reason: reason, authorized_by: source}`
  - `[:pag_server, :tools, :registry, :unregister]` - emitted on unregistration
    - Metadata: `%{tool_name: name}`
- [ ] Add Logger.info calls for all registration events with structured metadata
- [ ] Add optional `restrict_registration` config flag:
  - When `true`, only registrations with explicit `authorized_by` are allowed
  - When `false` (default), backward-compatible behavior preserved
  - Config: `config :pag_server, PagServer.Tools.Registry, restrict_registration: false`
- [ ] Add timestamp tracking: store when each tool was registered in the ETS entry
  - Extend ETS tuple from `{name, module, schema}` to `{name, module, schema, registered_at, authorized_by}`
  - Add `Registry.info(tool_name)` function returning registration metadata
- [ ] Write tests:
  - Test telemetry events are emitted on register/unregister
  - Test authorized_by metadata is stored and retrievable
  - Test restrict_registration config blocks unauthorized registration
  - Test backward compatibility (register/1 still works)

## Acceptance Criteria

- [ ] Tool registrations emit telemetry events with authorization context
- [ ] Registration/unregistration events are logged with structured metadata
- [ ] `Registry.info/1` returns registration metadata including when and by whom
- [ ] `restrict_registration: true` config blocks registrations without explicit authorization
- [ ] Backward compatibility preserved - existing `register/1` calls still work
- [ ] No performance regression on hot path (ETS lookups unchanged)

## Context

**Source**: Architecture audit - tool system security gap analysis (2026-02-06)
**Severity**: MEDIUM - no immediate exploit vector but creates risk for tool injection in multi-tenant scenarios

**Related tasks**:
- P4.M1.E2 (Registry GenServer) - original implementation
- P7.M3.E6 (MCP Security Hardening) - MCP servers register proxy tools

## Notes

Current registration in `lib/pag_server/tools/registry.ex` (line 107):
```elixir
@spec register(module()) :: :ok | {:error, :invalid_tool | :duplicate_name}
def register(module) do
  GenServer.call(__MODULE__, {:register, module})
end
```

Proposed change:
```elixir
@spec register(module(), keyword()) :: :ok | {:error, :invalid_tool | :duplicate_name | :unauthorized}
def register(module, opts \\ []) do
  GenServer.call(__MODULE__, {:register, module, opts})
end
```

Handle_call addition:
```elixir
def handle_call({:register, module, opts}, _from, state) do
  authorized_by = Keyword.get(opts, :authorized_by, "system")

  if state.restrict_registration and authorized_by == "system" do
    {:reply, {:error, :unauthorized}, state}
  else
    case do_register(module, state) do
      {:ok, new_state} ->
        :telemetry.execute(
          [:pag_server, :tools, :registry, :register],
          %{count: 1},
          %{tool_name: module.schema().name, module: module, authorized_by: authorized_by}
        )
        {:reply, :ok, new_state}
      {:error, reason} ->
        :telemetry.execute(
          [:pag_server, :tools, :registry, :register_failed],
          %{count: 1},
          %{module: module, reason: reason, authorized_by: authorized_by}
        )
        {:reply, {:error, reason}, state}
    end
  end
end
```

**Key files**:
- `lib/pag_server/tools/registry.ex` (primary)
- `config/config.exs` (new config option)
- `test/pag_server/tools/registry_test.exs` (tests)
