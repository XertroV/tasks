---
id: P3.M5.E2.T002
title: Create bearer token validation plug
status: done
estimate_hours: 1.5
complexity: medium
priority: high
depends_on:
- P3.M5.E1.T001
- P3.M5.E2.T001
tags:
- auth
- jwt
- plug
claimed_by: cli-user
claimed_at: '2026-02-06T18:26:32.234775+00:00'
started_at: '2026-02-06T18:26:32.234775+00:00'
completed_at: '2026-02-06T18:41:54.860334+00:00'
duration_minutes: 15.377092483333334
---

# Create bearer token validation plug



## Requirements

- [ ] Create `lib/pag_server_web/plugs/require_bearer_token.ex` plug module
- [ ] Implement `init/1` callback to configure plug options
- [ ] Implement `call/2` callback to extract and validate Bearer tokens
- [ ] Extract token from `Authorization: Bearer <token>` header
- [ ] Validate token using `PagServer.Auth.Token.decode_token/1`
- [ ] Load API key from database to verify it's not revoked
- [ ] Store authenticated API key in `conn.assigns.current_api_key`
- [ ] Return 401 Unauthorized if token missing or invalid
- [ ] Return 403 Forbidden if API key revoked or expired
- [ ] Add proper error JSON responses
- [ ] Emit telemetry for successful/failed authentication
- [ ] Support optional authentication (`:optional` mode)
- [ ] Add comprehensive test coverage

## Acceptance Criteria

- [ ] Plug module created at `lib/pag_server_web/plugs/require_bearer_token.ex`
- [ ] `init/1` returns options map with `:optional` key (default: false)
- [ ] `call/2` extracts token from `Authorization: Bearer <token>` header
- [ ] Handles missing `Authorization` header gracefully
- [ ] Handles malformed header (not starting with "Bearer ")
- [ ] Validates token using `PagServer.Auth.Token.decode_token/1`
  - [ ] Queries database for API key using `sub` claim (api_key_id)
  - [ ] Checks API key: `revoked_at` must be NULL, `expires_at` must be NULL or future
- [ ] Sets `conn.assigns.current_api_key` with full APIKey struct
- [ ] Sets `conn.assigns.current_api_key_id` for convenience
- [ ] Returns 401 with `{"error": "unauthorized", "message": "Missing or invalid token"}` if token invalid
- [ ] Returns 403 with `{"error": "forbidden", "message": "API key revoked"}` if key revoked
- [ ] Returns 403 with `{"error": "forbidden", "message": "API key expired"}` if key expired
- [ ] Optional mode allows request to proceed without token (assigns remain nil)
- [ ] Telemetry emitted: `[:pag_server, :auth, :bearer_validated]` (success), `[:pag_server, :auth, :bearer_failed]` (failure)
- [ ] Tests cover: valid token, missing header, invalid token, expired token, revoked key, optional mode
- [ ] `mix test` passes with all plug tests green
- [ ] No compilation warnings

## Context

This plug sits in the Phoenix router pipeline to protect API endpoints. It enforces that clients must provide a valid JWT Bearer token derived from an API key.

**Authentication Flow**:
1. Client includes `Authorization: Bearer <jwt>` header
2. Plug extracts token from header
3. Plug validates JWT signature and expiration
4. Plug loads API key from database using token's `sub` claim
5. Plug verifies API key is active (not revoked/expired)
6. Request proceeds with `current_api_key` in assigns

**Router Integration** (in `lib/pag_server_web/router.ex`):
```elixir
pipeline :authenticated_api do
  plug :accepts, ["json"]
  plug PagServerWeb.Plugs.RequireBearerToken
end

scope "/api", PagServerWeb do
  pipe_through :authenticated_api
  
  resources "/agents", AgentController
  resources "/sessions", SessionController
end
```

**Optional Authentication** (for public + authenticated endpoints):
```elixir
pipeline :optional_auth do
  plug :accepts, ["json"]
  plug PagServerWeb.Plugs.RequireBearerToken, optional: true
end
```

## Implementation Notes

### Plug Module Structure

```elixir
defmodule PagServerWeb.Plugs.RequireBearerToken do
  @moduledoc """
  Plug to validate JWT Bearer tokens and load authenticated API key.
  
  Extracts token from Authorization header, validates it, and loads
  the associated API key from the database.
  
  ## Options
  - `:optional` - Allow requests without tokens (default: false)
  
  ## Examples
  
      # Required authentication
      plug RequireBearerToken
      
      # Optional authentication
      plug RequireBearerToken, optional: true
  """

  import Plug.Conn
  require Logger

  alias PagServer.Auth.Token
  alias PagServer.Repo
  alias PagServer.Schema.ApiKey

  @behaviour Plug

  @impl true
  def init(opts), do: Keyword.put_new(opts, :optional, false)

  @impl true
  def call(conn, opts) do
    case extract_token(conn) do
      {:ok, token} ->
        validate_and_load(conn, token)
        
      :error ->
        if opts[:optional] do
          conn
        else
          unauthorized(conn, "Missing or invalid Authorization header")
        end
    end
  end

  # Extract Bearer token from Authorization header
  defp extract_token(conn) do
    case get_req_header(conn, "authorization") do
      ["Bearer " <> token] -> {:ok, token}
      _ -> :error
    end
  end

  # Validate token and load API key
  defp validate_and_load(conn, token) do
    with {:ok, claims} <- Token.decode_token(token),
         api_key_id <- Map.get(claims, "sub"),
         {:ok, api_key} <- load_api_key(api_key_id),
         :ok <- verify_api_key_active(api_key) do
      
      emit_telemetry(:bearer_validated, %{api_key_id: api_key.id})
      
      conn
      |> assign(:current_api_key, api_key)
      |> assign(:current_api_key_id, api_key.id)
    else
      {:error, :revoked} ->
        emit_telemetry(:bearer_failed, %{reason: :revoked})
        forbidden(conn, "API key revoked")
        
      {:error, :expired} ->
        emit_telemetry(:bearer_failed, %{reason: :expired})
        forbidden(conn, "API key expired")
        
      {:error, :not_found} ->
        emit_telemetry(:bearer_failed, %{reason: :not_found})
        unauthorized(conn, "Invalid API key")
        
      {:error, _reason} ->
        emit_telemetry(:bearer_failed, %{reason: :invalid_token})
        unauthorized(conn, "Invalid or expired token")
    end
  end

  # Load API key from database
  defp load_api_key(api_key_id) do
    case Repo.get(ApiKey, api_key_id) do
      nil -> {:error, :not_found}
      api_key -> {:ok, api_key}
    end
  end

  # Verify API key is active (not revoked, not expired)
  defp verify_api_key_active(%ApiKey{revoked_at: revoked_at}) when not is_nil(revoked_at) do
    {:error, :revoked}
  end
  defp verify_api_key_active(%ApiKey{expires_at: expires_at}) when not is_nil(expires_at) do
    if DateTime.compare(expires_at, DateTime.utc_now()) == :lt do
      {:error, :expired}
    else
      :ok
    end
  end
  defp verify_api_key_active(%ApiKey{}), do: :ok

  # Return 401 Unauthorized
  defp unauthorized(conn, message) do
    conn
    |> put_status(401)
    |> Phoenix.Controller.json(%{error: "unauthorized", message: message})
    |> halt()
  end

  # Return 403 Forbidden
  defp forbidden(conn, message) do
    conn
    |> put_status(403)
    |> Phoenix.Controller.json(%{error: "forbidden", message: message})
    |> halt()
  end

  defp emit_telemetry(event, metadata) do
    :telemetry.execute(
      [:pag_server, :auth, event],
      %{count: 1},
      metadata
    )
  end
end
```

### Testing Strategy

Create `test/pag_server_web/plugs/require_bearer_token_test.exs`:

```elixir
defmodule PagServerWeb.Plugs.RequireBearerTokenTest do
  use PagServerWeb.ConnCase, async: true
  
  alias PagServerWeb.Plugs.RequireBearerToken
  alias PagServer.Auth.Token

  setup do
    # Create valid API key
    api_key = insert(:api_key, status: "active")
    {:ok, access_token, _refresh_token} = Token.generate_token(api_key.id)
    
    %{api_key: api_key, token: access_token}
  end

  describe "call/2 with valid token" do
    test "authenticates and assigns current_api_key", %{conn: conn, api_key: api_key, token: token} do
      conn =
        conn
        |> put_req_header("authorization", "Bearer #{token}")
        |> RequireBearerToken.call([])
      
      refute conn.halted
      assert conn.assigns.current_api_key.id == api_key.id
      assert conn.assigns.current_api_key_id == api_key.id
    end
  end

  describe "call/2 with missing token" do
    test "returns 401 Unauthorized", %{conn: conn} do
      conn = RequireBearerToken.call(conn, [])
      
      assert conn.halted
      assert conn.status == 401
      assert json_response(conn, 401) == %{
        "error" => "unauthorized",
        "message" => "Missing or invalid Authorization header"
      }
    end
  end

  describe "call/2 with invalid token" do
    test "returns 401 Unauthorized", %{conn: conn} do
      conn =
        conn
        |> put_req_header("authorization", "Bearer invalid.jwt.token")
        |> RequireBearerToken.call([])
      
      assert conn.halted
      assert conn.status == 401
    end
  end

  describe "call/2 with revoked API key" do
    test "returns 403 Forbidden", %{conn: conn, api_key: api_key, token: token} do
      # Revoke the key
      Repo.update!(Ecto.Changeset.change(api_key, revoked_at: DateTime.utc_now()))
      
      conn =
        conn
        |> put_req_header("authorization", "Bearer #{token}")
        |> RequireBearerToken.call([])
      
      assert conn.halted
      assert conn.status == 403
      assert json_response(conn, 403)["message"] == "API key revoked"
    end
  end

  describe "optional mode" do
    test "allows requests without tokens", %{conn: conn} do
      conn = RequireBearerToken.call(conn, optional: true)
      
      refute conn.halted
      refute Map.has_key?(conn.assigns, :current_api_key)
    end
  end
end
```

### Dependencies

- Requires `PagServer.Auth.Token` module (Task T001)
- Requires `APIKey` schema from Epic P3.M5.E1.T001
- Uses Phoenix.Controller for JSON responses
- Uses Plug.Conn for connection manipulation
