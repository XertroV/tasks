---
id: P4.M2.E6.T001
title: Implement http_get tool
status: done
estimate_hours: 2.0
complexity: medium
priority: high
depends_on: []
tags:
- tools
- http
- builtin
claimed_by: cli-user
claimed_at: '2026-02-06T02:42:13.640092'
started_at: '2026-02-06T02:42:13.640092'
completed_at: '2026-02-06T02:57:13.335135'
duration_minutes: 14.994917133333333
---

# Implement http_get tool



## Requirements

- [ ] Create `lib/pag_server/tools/builtin/http_get.ex` (~150 LoC)
- [ ] Implement Tool behaviour (name, schema, execute)
- [ ] Support URL, headers, query parameters
- [ ] Use HTTP client library (Req or Finch)
- [ ] Follow redirects automatically (configurable)
- [ ] Timeout configuration (default 30s)
- [ ] Validate URL format and allowed protocols (http/https only)

## Acceptance Criteria

- [ ] Makes HTTP GET requests to provided URL
- [ ] Accepts optional headers as key-value map
- [ ] Accepts optional query parameters as key-value map
- [ ] Follows redirects (max 5 by default)
- [ ] Returns response body, status code, and headers
- [ ] Handles common errors: timeout, network failure, invalid URL, 4xx/5xx responses
- [ ] Validates URL is http:// or https:// (blocks file://, ftp://, etc.)
- [ ] Truncates response body at 512KB limit
- [ ] Test coverage: successful GET, with headers, with query params, redirects, timeout, invalid URL, 404, 500 errors
- [ ] Security: blocks localhost/private IPs (SSRF protection)

## Context

**Plan References**:
- `.plan/2026-02-05-velvet-cascade/architecture.md` lines 343-355 (Builtin tools)

**Key Points**:
- SSRF protection: block localhost, 127.0.0.1, 0.0.0.0, 10.*, 172.16.*, 192.168.*, link-local
- Truncate large responses to prevent memory issues
- Return structured data (status, headers, body)
- Use connection pooling for performance

## Notes

Implementation pattern:
```elixir
defmodule PAGServer.Tools.Builtin.HttpGet do
  @behaviour PAGServer.Tools.Tool
  @max_response_bytes 512_000  # 512KB
  @default_timeout 30_000  # 30 seconds

  @impl true
  def name, do: "http_get"

  @impl true
  def schema do
    %ToolSchema{
      name: "http_get",
      description: "Make HTTP GET request to a URL",
      parameters: %{
        type: "object",
        properties: %{
          url: %{
            type: "string",
            description: "URL to fetch (http:// or https://)"
          },
          headers: %{
            type: "object",
            description: "Optional HTTP headers",
            additionalProperties: %{type: "string"}
          },
          params: %{
            type: "object",
            description: "Optional query parameters",
            additionalProperties: %{type: "string"}
          },
          follow_redirects: %{
            type: "boolean",
            description: "Follow redirects (default: true)"
          },
          timeout_ms: %{
            type: "integer",
            description: "Request timeout in milliseconds (default: 30000)"
          }
        },
        required: ["url"]
      }
    }
  end

  @impl true
  def execute(%{"url" => url} = args, _context) do
    with :ok <- validate_url(url),
         :ok <- validate_ssrf(url),
         {:ok, response} <- make_request(url, args) do
      {:ok, %{
        status: response.status,
        headers: response.headers,
        body: truncate_body(response.body)
      }}
    else
      {:error, reason} -> {:error, "HTTP GET failed: #{inspect(reason)}"}
    end
  end

  defp validate_url(url) do
    uri = URI.parse(url)
    if uri.scheme in ["http", "https"] and uri.host do
      :ok
    else
      {:error, "Invalid URL: must be http:// or https://"}
    end
  end

  defp validate_ssrf(url) do
    uri = URI.parse(url)
    host = uri.host |> to_string() |> String.downcase()
    
    blocked = [
      "localhost", "127.0.0.1", "0.0.0.0", "::1",
      # Check for private IP ranges
      ~r/^10\./,
      ~r/^172\.(1[6-9]|2[0-9]|3[01])\./,
      ~r/^192\.168\./,
      ~r/^169\.254\./  # Link-local
    ]
    
    if Enum.any?(blocked, fn
      pattern when is_binary(pattern) -> host == pattern
      %Regex{} = regex -> Regex.match?(regex, host)
    end) do
      {:error, "Access to private/local addresses blocked"}
    else
      :ok
    end
  end

  defp make_request(url, args) do
    headers = Map.get(args, "headers", %{})
    params = Map.get(args, "params", %{})
    timeout = Map.get(args, "timeout_ms", @default_timeout)
    follow = Map.get(args, "follow_redirects", true)
    
    Req.get(url,
      headers: headers,
      params: params,
      receive_timeout: timeout,
      redirect: follow,
      max_redirects: 5
    )
  end

  defp truncate_body(body) when byte_size(body) > @max_response_bytes do
    binary_part(body, 0, @max_response_bytes) <>
      "\n\n[Response truncated at 512KB]"
  end
  defp truncate_body(body), do: body
end
```

Example usage:
```json
{
  "url": "https://api.github.com/repos/user/repo",
  "headers": {
    "Accept": "application/json",
    "User-Agent": "PAG-Server/1.0"
  },
  "params": {
    "per_page": "10"
  }
}
```

Example response:
```json
{
  "status": 200,
  "headers": {
    "content-type": "application/json"
  },
  "body": "{...}"
}
```

Security considerations:
- SSRF protection essential (block private IPs)
- Response size limits to prevent memory exhaustion
- Timeout to prevent hanging requests
- Validate URL scheme (no file://, javascript:, etc.)
