---
id: P4.M1.E2.T001
title: Implement Registry GenServer
status: done
estimate_hours: 1.5
complexity: medium
priority: high
depends_on: []
tags:
- tools
- registry
- genserver
- otp
claimed_by: cli-user
claimed_at: '2026-02-05T20:48:47.318431'
started_at: '2026-02-05T20:48:47.318431'
completed_at: '2026-02-05T21:25:59.064887'
duration_minutes: 37.19577405
---

# Implement Registry GenServer

Create the `PAGServer.Tools.Registry` GenServer to manage tool registration and lookup.

## Requirements

- [x] Create `lib/pag_server/tools/registry.ex` (~200 LoC)
- [x] Implement GenServer with ETS table for tool storage
- [x] Add state: `%{ets_table: reference(), tools: map()}`
- [x] Implement `init/1` to create ETS table `:tools_registry`
- [x] Add Registry to supervision tree in `application.ex`

## Acceptance Criteria

- [x] GenServer starts successfully under supervision
- [x] ETS table is created with `:set` type and `:public` access
- [x] Process registered as `PagServer.Tools.Registry` name
- [x] Crashes are handled gracefully (supervisor restarts)
- [x] Test coverage for initialization and supervision

## Context

**Plan References**:
- `.plan/2026-02-05-velvet-cascade/architecture.md` lines 333-336 (Registry structure)

**Key Points**:
- Registry is a singleton GenServer (one per node)
- ETS provides fast concurrent reads
- GenServer handles writes (register/unregister)
- Tools are identified by unique name strings

## Notes

Registry implementation pattern:
```elixir
defmodule PAGServer.Tools.Registry do
  use GenServer

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @impl true
  def init(_opts) do
    table = :ets.new(:tools_registry, [:set, :public, :named_table])
    {:ok, %{ets_table: table, tools: %{}}}
  end
end
```

Add to supervision tree in `application.ex`:
```elixir
children = [
  # ... existing children
  PAGServer.Tools.Registry
]
```

ETS table structure:
- Key: tool name (string)
- Value: `{module, schema}` tuple

Why both ETS and state map?
- ETS: Fast concurrent reads for tool lookup
- State map: Backup for recreation after crashes


## Delegation Instructions

**Delegated to subagent by**: cli-user (primary agent)
**Delegation date**: 2026-02-06 07:48 UTC
**Primary task**: P2.M8.E5.T001 - Implement adaptive chunk sizing for summarization

**Instructions**:
This task was claimed as part of a multi-task batch. The primary agent (cli-user)
should spawn a subagent to complete this task in parallel.

**Recommended approach**:
1. Use the Task tool with subagent_type to create a dedicated agent
2. Provide context from this task file as the prompt
3. Grant necessary tools for task completion
4. Monitor subagent progress
5. Aggregate results upon completion

**Independence verification**:
- Different epic: ✓ (P4.M1.E2 vs P2.M8.E5)
- No dependency chain: ✓ (verified at claim time)
