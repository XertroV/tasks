---
id: P8.M5.E2.T002
title: Process incoming WhatsApp messages
status: done
estimate_hours: 3.0
complexity: high
priority: high
depends_on: [P8.M5.E2.T001]
tags:
- whatsapp
- messages
- agent-routing
---

# Process incoming WhatsApp messages

Implement message processing pipeline from webhook to agent response.

## Requirements

- [x] Create `lib/pag_server/integrations/whatsapp/message_handler.ex` (~120 LoC)
- [x] Parse webhook payload and extract messages
- [x] Create or retrieve session by phone number
- [x] Route message to agent GenServer
- [x] Send agent response back via Cloud API
- [x] Handle read receipts and typing indicators

## Acceptance Criteria

- [x] Text messages are processed end-to-end
- [x] Sessions are created on first message from new number
- [x] Agent responses are sent within 2 seconds
- [x] Duplicate messages (by message_id) are deduplicated
- [x] Delivery status updates are tracked
- [x] Bot doesn't respond to its own messages

## Context

**Plan References**:
- `.plan/2026-02-05-velvet-cascade/integrations.md` lines 369-388 (message handling)
- `.plan/2026-02-05-velvet-cascade/architecture.md` lines 215-243 (session management)

**Key Points**:
- WhatsApp webhook sends batched updates in `entry` array
- Must track message IDs to avoid duplicate processing
- Session includes phone number as external identifier
- Agent context includes WhatsApp profile info if available

## Notes

Message processing flow:
```elixir
def handle_webhook(%{"entry" => entries}) do
  for entry <- entries,
      change <- entry["changes"],
      message <- get_in(change, ["value", "messages"]) || [] do
    
    unless already_processed?(message["id"]) do
      process_message(message, change["value"])
    end
  end
end

defp process_message(%{"from" => phone, "text" => %{"body" => text}}, metadata) do
  {:ok, session} = SessionManager.get_or_create(
    platform: :whatsapp,
    external_id: phone,
    metadata: %{
      profile_name: metadata["contacts"] |> List.first() |> get_in(["profile", "name"])
    }
  )
  
  # Send typing indicator
  CloudAPI.mark_typing(phone)
  
  # Process with agent
  {:ok, response} = Agent.send_message(session.agent_id, text)
  
  # Send response
  CloudAPI.send_text_message(phone, response.content)
  
  # Mark as read
  CloudAPI.mark_read(message["id"])
end
```

Deduplication strategy:
- Store processed message IDs in Redis with 24h TTL
- Use SET NX for atomic check-and-set
- Key format: `whatsapp:msg:{message_id}`

Status tracking:
- `sent` → Message accepted by WhatsApp
- `delivered` → Message delivered to phone
- `read` → User opened message
- `failed` → Delivery failed

## Implementation Notes

### Files Created
- `lib/pag_server/integrations/whatsapp/message_handler.ex` (287 LoC)
- `test/pag_server/integrations/whatsapp/message_handler_test.exs`

### Features Implemented

1. **Webhook Parsing**: Handles `entry` array with batched updates
2. **Deduplication**: Uses Cachex with 24h TTL for message IDs
3. **Session Management**: Creates/retrieves sessions by phone number via `session_key`
4. **Agent Routing**: Routes messages to `AgentServer.send_message_by_id/3`
5. **Response Handling**: Sends agent responses via `CloudAPI.send_text_message/3`
6. **Typing Indicators**: Sends `typing_on` status before processing
7. **Read Receipts**: Marks messages as read after sending responses
8. **Bot Filtering**: Ignores messages from bot's own phone number

### Test Infrastructure Issue

**Blocker**: Nostrum library (Discord integration) cannot be started in test environment due to invalid token.

**Root Cause**: Nostrum tries to connect to Discord API even with `start_shards: false` and `num_shards: 0` config.

**Workaround Options**:
1. Fix Nostrum configuration to properly prevent shard startup
2. Add a Discord integration supervisor that conditionally starts Nostrum
3. Update test environment configuration

**Impact**: Unit tests cannot be run until this infrastructure issue is resolved. The implementation follows the Matrix integration pattern and should work correctly once test infrastructure is fixed.
