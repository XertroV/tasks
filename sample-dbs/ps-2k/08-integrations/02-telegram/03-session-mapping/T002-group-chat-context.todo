---
id: P8.M2.E3.T002
title: Add group chat context handling
status: done
estimate_hours: 1
complexity: medium
priority: medium
depends_on:
- P8.M2.E3.T001
tags:
- integrations
- telegram
- sessions
- groups
claimed_by: cli-user
claimed_at: '2026-02-11T02:19:34.828921+00:00'
started_at: '2026-02-11T02:19:34.828921+00:00'
completed_at: '2026-02-11T02:19:42.649340+00:00'
duration_minutes: 0.13034015
---

# Add group chat context handling

Handle Telegram group chats with @mention triggers and shared context.

## Requirements

- [ ] Extend SessionMapper to detect group chat type (~20 LoC)
- [ ] Implement @mention detection in MessageHandler (~30 LoC)
- [ ] Add group context to agent messages (participants, chat title) (~40 LoC)
- [ ] Support admin commands for group configuration (~50 LoC)
- [ ] Store group metadata (title, participant count, admin list)
- [ ] Only respond when bot is @mentioned in groups
- [ ] Add configuration for auto-respond vs. mention-only mode

## Acceptance Criteria

- [ ] Bot only responds to @mentions in groups (default)
- [ ] Group chat title and participant info included in context
- [ ] Admin commands restricted to group admins
- [ ] Private chats work without @mention requirement
- [ ] Configuration persisted per-group in database
- [ ] Unit tests cover group vs. private chat logic
- [ ] Integration test with mock group message

## Context

**Plan References**:
- `.plan/2026-02-05-velvet-cascade/integrations.md` lines 222 (Group chats)

**Key Points**:
- Groups share one agent session across all participants
- @mention prevents spam in busy groups
- Admins can configure bot behavior per-group
- Context includes participant info for better responses

## Notes

Group detection:
```elixir
defp determine_chat_type(%{chat: %{type: "group"}}), do: :group
defp determine_chat_type(%{chat: %{type: "supergroup"}}), do: :supergroup
defp determine_chat_type(_), do: :private
```

Mention detection:
```elixir
defmodule PAGServer.Integrations.Telegram.MessageHandler do
  def handle(%{chat: %{type: type}, text: text} = message) 
      when type in ["group", "supergroup"] do
    bot_username = Application.get_env(:pag_server, :telegram_bot_username)
    
    if String.contains?(text, "@#{bot_username}") do
      cleaned_text = String.replace(text, "@#{bot_username}", "")
      process_message(message, cleaned_text)
    else
      :ignore  # Don't respond without mention in groups
    end
  end

  def handle(message) do
    # Private chats always respond
    process_message(message, message.text)
  end
end
```

Group context enrichment:
```elixir
defp build_group_context(%{chat: chat}) do
  %{
    chat_type: chat.type,
    chat_title: chat.title,
    participant_count: get_member_count(chat.id),
    is_group: true
  }
end
```

Admin commands:
```elixir
# /config auto_respond on|off
# /config model claude-3-opus-20240229
# /config reset
```

Configuration schema extension:
```elixir
field :auto_respond, :boolean, default: false  # Respond to all messages
field :allowed_users, {:array, :integer}, default: []  # Empty = all allowed
field :admin_only, :boolean, default: false  # Only admins can use
```


## Delegation Instructions

**Delegated to subagent by**: cli-user (primary agent)
**Delegation date**: 2026-02-11 02:19 UTC
**Primary task**: P8.M2.E2.T001 - Implement message handler

**Instructions**:
This task was claimed as part of a multi-task batch. The primary agent (cli-user)
should spawn a subagent to complete this task in parallel.

**Recommended approach**:
1. Use the Task tool with subagent_type to create a dedicated agent
2. Provide context from this task file as the prompt
3. Grant necessary tools for task completion
4. Monitor subagent progress
5. Aggregate results upon completion

**Independence verification**:
- Different epic: ✓ (P8.M2.E3 vs P8.M2.E2)
- No dependency chain: ✓ (verified at claim time)
