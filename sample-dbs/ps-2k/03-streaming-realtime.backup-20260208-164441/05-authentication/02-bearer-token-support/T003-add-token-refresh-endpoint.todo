---
id: P3.M5.E2.T003
title: Add token refresh endpoint
status: done
estimate_hours: 1.0
complexity: low
priority: medium
depends_on:
- P3.M5.E2.T001
tags:
- auth
- jwt
- api
claimed_by: cli-user
claimed_at: '2026-02-06T18:26:32.235914+00:00'
started_at: '2026-02-06T18:26:32.235914+00:00'
completed_at: '2026-02-06T18:41:55.645048+00:00'
duration_minutes: 15.390152066666667
---

# Add token refresh endpoint



## Requirements

- [ ] Create `lib/pag_server_web/controllers/auth_controller.ex`
- [ ] Implement `refresh/2` action to handle token refresh
- [ ] Accept refresh token in request body (`{"refresh_token": "..."}`)
- [ ] Validate refresh token using `PagServer.Auth.Token.decode_token/1`
- [ ] Verify token type is "refresh" (not "access")
- [ ] Load and verify API key is still active
- [ ] Generate new access + refresh token pair
- [ ] Return new tokens in response
- [ ] Add route to `router.ex`: `POST /api/auth/refresh`
- [ ] Add error handling for invalid/expired refresh tokens
- [ ] Emit telemetry for refresh operations
- [ ] Create comprehensive tests

## Acceptance Criteria

- [ ] Controller created at `lib/pag_server_web/controllers/auth_controller.ex`
- [ ] `refresh/2` action accepts POST requests
- [ ] Parses `refresh_token` from request body JSON
- [ ] Returns 400 if `refresh_token` missing from body
- [ ] Validates refresh token using `Token.decode_token/1`
- [ ] Checks token type claim is "refresh" (rejects "access" tokens)
- [ ] Returns 401 if refresh token invalid or expired
- [ ] Loads API key from database using token's `sub` claim
- [ ] Returns 403 if API key revoked or expired
- [ ] Generates new access + refresh token pair on success
- [ ] Response includes both tokens: `{"access_token": "...", "refresh_token": "...", "expires_in": 3600}`
- [ ] Route added to router: `post "/api/auth/refresh", AuthController, :refresh`
- [ ] Route is public (not behind authentication pipeline)
- [ ] Telemetry emitted: `[:pag_server, :auth, :token_refreshed]` (success), `[:pag_server, :auth, :refresh_failed]` (failure)
- [ ] Tests cover: valid refresh, invalid token, expired token, access token rejected, revoked API key
- [ ] JSON view module created for consistent response format
- [ ] `mix test` passes with all controller tests green
- [ ] No compilation warnings

## Context

Token refresh enables seamless re-authentication without requiring the user to re-enter API credentials. This improves security by:
- **Short-lived access tokens**: Reduce exposure window if token leaked
- **Long-lived refresh tokens**: Reduce friction for legitimate users
- **Revocability**: Revoking API key invalidates all tokens immediately

**Refresh Flow**:
1. Client's access token expires (1 hour default)
2. Client calls `POST /api/auth/refresh` with refresh token
3. Server validates refresh token (7 day expiration)
4. Server generates new access + refresh token pair
5. Client stores new tokens, continues making requests

**Alternative**: Clients could re-authenticate with API key, but refresh is preferred:
- Reduces API key exposure (only used once to get initial tokens)
- Enables token rotation (new refresh token on each refresh)
- Provides better audit trail (separate telemetry events)

## Implementation Notes

### Controller Module

```elixir
defmodule PagServerWeb.AuthController do
  use PagServerWeb, :controller

  require Logger

  alias PagServer.Auth.Token
  alias PagServer.Repo
  alias PagServer.Schema.APIKey

  @doc """
  Refresh access token using a valid refresh token.
  
  ## Request Body
  ```json
  {
    "refresh_token": "eyJhbGc..."
  }
  ```
  
  ## Success Response (200)
  ```json
  {
    "access_token": "eyJhbGc...",
    "refresh_token": "eyJhbGc...",
    "token_type": "Bearer",
    "expires_in": 3600
  }
  ```
  """
  def refresh(conn, %{"refresh_token" => refresh_token}) do
    with {:ok, claims} <- Token.decode_token(refresh_token),
         :ok <- verify_refresh_token(claims),
         {:ok, api_key} <- load_and_verify_api_key(claims["sub"]),
         {:ok, access_token, new_refresh_token} <- Token.generate_token(api_key.id) do
      
      emit_telemetry(:token_refreshed, %{api_key_id: api_key.id})
      
      json(conn, %{
        access_token: access_token,
        refresh_token: new_refresh_token,
        token_type: "Bearer",
        expires_in: 3600
      })
    else
      {:error, :not_refresh_token} ->
        emit_telemetry(:refresh_failed, %{reason: :wrong_token_type})
        conn
        |> put_status(401)
        |> json(%{error: "invalid_token", message: "Must provide refresh token, not access token"})
        
      {:error, :revoked} ->
        emit_telemetry(:refresh_failed, %{reason: :revoked})
        conn
        |> put_status(403)
        |> json(%{error: "forbidden", message: "API key revoked"})
        
      {:error, :expired_key} ->
        emit_telemetry(:refresh_failed, %{reason: :expired_key})
        conn
        |> put_status(403)
        |> json(%{error: "forbidden", message: "API key expired"})
        
      {:error, :not_found} ->
        emit_telemetry(:refresh_failed, %{reason: :not_found})
        conn
        |> put_status(401)
        |> json(%{error: "invalid_token", message: "Invalid API key"})
        
      {:error, _reason} ->
        emit_telemetry(:refresh_failed, %{reason: :invalid_token})
        conn
        |> put_status(401)
        |> json(%{error: "invalid_token", message: "Invalid or expired refresh token"})
    end
  end

  def refresh(conn, _params) do
    conn
    |> put_status(400)
    |> json(%{error: "bad_request", message: "Missing refresh_token in request body"})
  end

  # Verify token is a refresh token, not access token
  defp verify_refresh_token(%{"type" => "refresh"}), do: :ok
  defp verify_refresh_token(_claims), do: {:error, :not_refresh_token}

  # Load API key and verify it's active
  defp load_and_verify_api_key(api_key_id) do
    case Repo.get(APIKey, api_key_id) do
      nil -> 
        {:error, :not_found}
        
      %APIKey{status: "revoked"} -> 
        {:error, :revoked}
        
      %APIKey{expires_at: expires_at} = api_key when not is_nil(expires_at) ->
        if DateTime.compare(expires_at, DateTime.utc_now()) == :lt do
          {:error, :expired_key}
        else
          {:ok, api_key}
        end
        
      api_key ->
        {:ok, api_key}
    end
  end

  defp emit_telemetry(event, metadata) do
    :telemetry.execute(
      [:pag_server, :auth, event],
      %{count: 1},
      metadata
    )
  end
end
```

### Router Configuration

Add to `lib/pag_server_web/router.ex`:

```elixir
scope "/api", PagServerWeb do
  pipe_through :api
  
  # Public auth endpoints (no authentication required)
  post "/auth/refresh", AuthController, :refresh
end

scope "/api", PagServerWeb do
  pipe_through [:api, :authenticate]
  
  # Protected endpoints...
  resources "/agents", AgentController
  resources "/sessions", SessionController
end
```

### Testing Strategy

Create `test/pag_server_web/controllers/auth_controller_test.exs`:

```elixir
defmodule PagServerWeb.AuthControllerTest do
  use PagServerWeb.ConnCase, async: true

  alias PagServer.Auth.Token

  setup do
    api_key = insert(:api_key, status: "active")
    {:ok, _access, refresh_token} = Token.generate_token(api_key.id)
    
    %{api_key: api_key, refresh_token: refresh_token}
  end

  describe "POST /api/auth/refresh" do
    test "returns new tokens with valid refresh token", %{conn: conn, refresh_token: refresh_token} do
      conn = post(conn, ~p"/api/auth/refresh", %{refresh_token: refresh_token})
      
      assert %{
        "access_token" => access_token,
        "refresh_token" => new_refresh_token,
        "token_type" => "Bearer",
        "expires_in" => 3600
      } = json_response(conn, 200)
      
      assert is_binary(access_token)
      assert is_binary(new_refresh_token)
      assert access_token != refresh_token
      assert new_refresh_token != refresh_token
    end

    test "returns 400 if refresh_token missing", %{conn: conn} do
      conn = post(conn, ~p"/api/auth/refresh", %{})
      
      assert %{"error" => "bad_request"} = json_response(conn, 400)
    end

    test "returns 401 if refresh_token invalid", %{conn: conn} do
      conn = post(conn, ~p"/api/auth/refresh", %{refresh_token: "invalid.token"})
      
      assert %{"error" => "invalid_token"} = json_response(conn, 401)
    end

    test "returns 401 if access token provided instead of refresh", %{conn: conn, api_key: api_key} do
      {:ok, access_token, _refresh} = Token.generate_token(api_key.id)
      
      conn = post(conn, ~p"/api/auth/refresh", %{refresh_token: access_token})
      
      assert %{
        "error" => "invalid_token",
        "message" => "Must provide refresh token, not access token"
      } = json_response(conn, 401)
    end

    test "returns 403 if API key revoked", %{conn: conn, api_key: api_key, refresh_token: refresh_token} do
      Repo.update!(Ecto.Changeset.change(api_key, status: "revoked"))
      
      conn = post(conn, ~p"/api/auth/refresh", %{refresh_token: refresh_token})
      
      assert %{
        "error" => "forbidden",
        "message" => "API key revoked"
      } = json_response(conn, 403)
    end

    test "returns 403 if API key expired", %{conn: conn, api_key: api_key, refresh_token: refresh_token} do
      expired_at = DateTime.add(DateTime.utc_now(), -1, :day)
      Repo.update!(Ecto.Changeset.change(api_key, expires_at: expired_at))
      
      conn = post(conn, ~p"/api/auth/refresh", %{refresh_token: refresh_token})
      
      assert %{
        "error" => "forbidden",
        "message" => "API key expired"
      } = json_response(conn, 403)
    end

    test "generates new refresh token (rotation)", %{conn: conn, refresh_token: refresh_token} do
      conn1 = post(conn, ~p"/api/auth/refresh", %{refresh_token: refresh_token})
      %{"refresh_token" => new_refresh_1} = json_response(conn1, 200)
      
      conn2 = post(conn, ~p"/api/auth/refresh", %{refresh_token: new_refresh_1})
      %{"refresh_token" => new_refresh_2} = json_response(conn2, 200)
      
      assert new_refresh_1 != new_refresh_2
      assert new_refresh_1 != refresh_token
    end
  end
end
```

### Security Considerations

- **Refresh token rotation**: Each refresh generates a new refresh token, limiting replay attack window
- **Single-use refresh tokens**: Consider invalidating old refresh token after use (requires token revocation list)
- **Rate limiting**: Consider adding rate limits to prevent brute force (implemented in P3.M5.E4)
- **Token type validation**: Prevents access tokens from being used as refresh tokens

### Dependencies

- Requires `PagServer.Auth.Token` module (Task T001)
- Requires `APIKey` schema from Epic P3.M5.E1.T001
- Uses Phoenix.Controller for request handling
