---
id: P3.M3.E1.T003
title: Add /health and /ready endpoints
status: done
estimate_hours: 1.5
complexity: low
priority: critical
depends_on: []
tags:
- api
- health
- kubernetes
- audit-gap
claimed_by: cli-user
claimed_at: '2026-02-06T16:23:57.960047'
started_at: '2026-02-06T16:23:57.960047'
completed_at: '2026-02-06T16:28:41.330760'
duration_minutes: 4.722845033333333
---

# Add /health and /ready endpoints

Implement liveness and readiness health check endpoints required for production deployment,
container orchestration (Kubernetes), and load balancer integration. The architecture audit
identified the complete absence of health check endpoints as a critical gap.

## Requirements

- [ ] Implement `GET /health` liveness endpoint:
  - [ ] Returns HTTP 200 with `{"status": "ok"}` if the BEAM VM is running
  - [ ] No dependency checks -- purely indicates the process is alive
  - [ ] Response time must be <10ms (no blocking operations)
- [ ] Implement `GET /ready` readiness endpoint:
  - [ ] Check database connectivity (Ecto.Repo query)
  - [ ] Check at least one LLM provider is configured and reachable (via LLM.Registry)
  - [ ] Check MCP server supervisor is running (if MCP is configured)
  - [ ] Return HTTP 200 with `{"status": "ready", "checks": {...}}` when all pass
  - [ ] Return HTTP 503 with `{"status": "not_ready", "checks": {...}}` when any fail
  - [ ] Each check includes its own status and latency
- [ ] Add routes to the Phoenix router (outside authentication middleware)
- [ ] Add timeout for each readiness check (500ms per check, 2s total)
- [ ] Include version info in health response (app version from mix.exs)

## Acceptance Criteria

- [ ] `GET /health` returns 200 when app is running
- [ ] `GET /ready` returns 200 when DB and LLM providers are available
- [ ] `GET /ready` returns 503 when DB is down (test with stopped DB)
- [ ] Response time for `/health` is <10ms
- [ ] Response time for `/ready` is <2s even with slow checks
- [ ] Endpoints do not require authentication
- [ ] JSON response body includes check details

## Context

**Source**: Architecture audit identified no health check endpoints as a critical production gap.
**Note**: This task was already planned in P3.M3 (REST API). Details added from audit findings.

## Notes

**Example Implementation**:
```elixir
defmodule PagServerWeb.HealthController do
  use PagServerWeb, :controller

  def health(conn, _params) do
    json(conn, %{status: "ok", version: Application.spec(:pag_server, :vsn)})
  end

  def ready(conn, _params) do
    checks = %{
      database: check_database(),
      llm_providers: check_llm_providers(),
      mcp_servers: check_mcp_servers()
    }

    all_ok = Enum.all?(checks, fn {_, v} -> v.status == :ok end)
    status_code = if all_ok, do: 200, else: 503

    conn
    |> put_status(status_code)
    |> json(%{status: if(all_ok, do: "ready", else: "not_ready"), checks: checks})
  end

  defp check_database do
    start = System.monotonic_time(:millisecond)
    case Ecto.Adapters.SQL.query(PagServer.Repo, "SELECT 1", []) do
      {:ok, _} -> %{status: :ok, latency_ms: elapsed(start)}
      {:error, reason} -> %{status: :error, error: inspect(reason)}
    end
  end
end
```

**Router**:
```elixir
scope "/" do
  pipe_through [:api]  # no auth
  get "/health", PagServerWeb.HealthController, :health
  get "/ready", PagServerWeb.HealthController, :ready
end
```
